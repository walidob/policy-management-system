// Generated by AI
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Configuration;
using Moq;
using PolicyManagement.Application.Interfaces.Repositories;
using PolicyManagement.Domain.Entities.TenantsDb;
using PolicyManagement.Infrastructure.Cache;
using PolicyManagement.Infrastructure.DbContexts.TenantsDbContexts;
using PolicyManagement.Infrastructure.Repositories;
using Finbuckle.MultiTenant.Abstractions;
using Microsoft.Extensions.Logging;

namespace PolicyManagement.Infrastructure.IntegrationTests;

public class UnitOfWorkTests
{
    [Fact]
    public async Task UnitOfWork_SaveChanges_ShouldPersistChanges()
    {
        // Arrange
        var options = new DbContextOptionsBuilder<TenantDbContextBase>()
            .UseInMemoryDatabase(databaseName: $"PolicyDb_{Guid.NewGuid()}")
            .ConfigureWarnings(w => w.Ignore(InMemoryEventId.TransactionIgnoredWarning))
            .Options;

        var mockMultiTenantContextAccessor = new Mock<IMultiTenantContextAccessor>();
        var mockConfiguration = new Mock<IConfiguration>();
        var mockCacheHelper = new Mock<ICacheHelper>();

        await using var dbContext = new TenantDbContextBase(options, mockMultiTenantContextAccessor.Object, mockConfiguration.Object);
        var policyRepository = new PolicyRepository(dbContext, mockCacheHelper.Object);
        var logger = Mock.Of<ILogger<UnitOfWork>>();

        var unitOfWork = new UnitOfWork(dbContext, policyRepository, logger);

        var policy = new Policy
        {
            Name = "Test Policy",
            Description = "This is a test policy",
            CreationDate = DateTime.UtcNow,
            EffectiveDate = DateTime.UtcNow,
            ExpiryDate = DateTime.UtcNow.AddYears(1),
            IsActive = true,
            PolicyTypeId = 1
        };

        // Act - Skip transaction calls, just use SaveChanges
        await unitOfWork.PolicyRepository.AddAsync(policy);
        await unitOfWork.SaveChangesAsync();

        // Assert
        await using var verifyContext = new TenantDbContextBase(options, mockMultiTenantContextAccessor.Object, mockConfiguration.Object);
        var savedPolicy = await verifyContext.Policies.FirstOrDefaultAsync(p => p.Name == "Test Policy");
        savedPolicy.Should().NotBeNull();
        savedPolicy.Description.Should().Be("This is a test policy");
    }

    [Fact]
    public async Task UnitOfWork_Repository_ShouldBeAccessible()
    {
        // Arrange
        var options = new DbContextOptionsBuilder<TenantDbContextBase>()
            .UseInMemoryDatabase(databaseName: $"PolicyDb_Repo_{Guid.NewGuid()}")
            .ConfigureWarnings(w => w.Ignore(InMemoryEventId.TransactionIgnoredWarning))
            .Options;

        var mockMultiTenantContextAccessor = new Mock<IMultiTenantContextAccessor>();
        var mockConfiguration = new Mock<IConfiguration>();
        var mockCacheHelper = new Mock<ICacheHelper>();

        await using var dbContext = new TenantDbContextBase(options, mockMultiTenantContextAccessor.Object, mockConfiguration.Object);
        var policyRepository = new PolicyRepository(dbContext, mockCacheHelper.Object);
        var logger = Mock.Of<ILogger<UnitOfWork>>();
        // Act
        var unitOfWork = new UnitOfWork(dbContext, policyRepository,logger);
        
        // Assert
        unitOfWork.PolicyRepository.Should().NotBeNull();
        unitOfWork.PolicyRepository.Should().BeAssignableTo<IPolicyRepository>();
    }

    [Fact]
    public async Task UnitOfWork_MultipleOperations_ShouldSucceed()
    {
        // Arrange
        var options = new DbContextOptionsBuilder<TenantDbContextBase>()
            .UseInMemoryDatabase(databaseName: $"PolicyDb_Multiple_{Guid.NewGuid()}")
            .ConfigureWarnings(w => w.Ignore(InMemoryEventId.TransactionIgnoredWarning))
            .Options;

        var mockMultiTenantContextAccessor = new Mock<IMultiTenantContextAccessor>();
        var mockConfiguration = new Mock<IConfiguration>();
        var mockCacheHelper = new Mock<ICacheHelper>();

        await using var dbContext = new TenantDbContextBase(options, mockMultiTenantContextAccessor.Object, mockConfiguration.Object);
        var policyRepository = new PolicyRepository(dbContext, mockCacheHelper.Object);
        var logger = Mock.Of<ILogger<UnitOfWork>>();

        var unitOfWork = new UnitOfWork(dbContext, policyRepository, logger);

        var policies = new List<Policy>
        {
            new Policy
            {
                Name = "Policy 1",
                Description = "First test policy",
                CreationDate = DateTime.UtcNow,
                EffectiveDate = DateTime.UtcNow,
                ExpiryDate = DateTime.UtcNow.AddYears(1),
                IsActive = true,
                PolicyTypeId = 1
            },
            new Policy
            {
                Name = "Policy 2",
                Description = "Second test policy",
                CreationDate = DateTime.UtcNow,
                EffectiveDate = DateTime.UtcNow,
                ExpiryDate = DateTime.UtcNow.AddYears(1),
                IsActive = true,
                PolicyTypeId = 1
            }
        };

        // Act - Add multiple entities in one operation
        foreach (var policy in policies)
        {
            await unitOfWork.PolicyRepository.AddAsync(policy);
        }
        await unitOfWork.SaveChangesAsync();

        // Assert
        await using var verifyContext = new TenantDbContextBase(options, mockMultiTenantContextAccessor.Object, mockConfiguration.Object);
        var count = await verifyContext.Policies.CountAsync();
        count.Should().Be(2);
        
        var savedPolicy1 = await verifyContext.Policies.FirstOrDefaultAsync(p => p.Name == "Policy 1");
        var savedPolicy2 = await verifyContext.Policies.FirstOrDefaultAsync(p => p.Name == "Policy 2");
        
        savedPolicy1.Should().NotBeNull();
        savedPolicy2.Should().NotBeNull();
    }
} 